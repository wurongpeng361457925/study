		Mysql
		（关系型数据库的基本所有工作都是围绕着索引和事务来实现的）

核心特色：
	1.基于文件存储
		
		注意的问题：    写入的磁盘io不能过大  连接数不能过多
				文件大小是否有限制

				HBase  HDFS 这些分布式的文件数据库来存储
	2.单进程多线程   （redis是单进程单线程的，通过NIO的方式和客户端交互，所以redis支持的并发数高）

		为什么mysql的事务不能跨连接？
			因为mysql是单进程多线程的，一个connection通过tcp连接到mysql，
			每一个tcp都是一个socket，socket是线程安全的		

	3.插件式的存储引擎

		存储引擎来跟底层的文件打交道，他来实现具体的索引和具体的事物

		
MySQL的存储引擎：
	
	MyISAM: 
		5.0版本之前的默认数据库存储引擎，最常用。
		拥有较高的插入，查询快，支持表级锁，支持全文索引（分词-->到排表的形式）
		并发效率低    但不支持事务  不支持外键  表 可以被压缩
		这里事务指的是 并发事务  锁的设计  多版本控制的设计
		
		存放在三个文件：
			.frm文件 （表定义）
			MYD 文件 （数据文件）
			MYI 文件  （索引文件）
	
	InnoDB: mysql5.5版本之后的默认引擎  采用表空间（tableSpace）来管理数据，存储表数据和索引（存放在.ibd文件中）
		事务型数据库的首选引擎  支持acid事务，支持行级锁定，支持外键，支持全文索引
		并发效率高   表很难被压缩
	
		存放：
			.frm 文件 (表定义)
			.ibd 文件 （表数据和索引文件，无法直接读取 -->因为放一起了，所以innoDB的索引称为聚集索引）
			ibdata1,ibdata2等：系统表空间文件，存储InnoDB系统信息和用户数据库表数据
			和索引，所有表共用
			InnoDB存储引擎主要基于两个文件：表空间数据文件和日志文件


		创建InnoDB表 必须包含auto_increment类型字段的索引	

	BOB：

	Memory:基于内存，表级锁

	merge:
	
	arctive:适合存储历史纪录的数据，插入快，查询慢
		
	csv：	

在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式也不同

MySQL索引的实现  ：叶节点加了指针的b+Tree来实现的

为什么用b+tree？
	因为1.b+tree底层是有序的，且每隔叶子也到根的距离都是相同的
		2.有个链表，对大的范围查询做优化

mysql索引的最核心原则： 最左匹配原则


B+Tree的点睛之笔： 每个叶子节点增加了一个指向相邻节点的指针，形成了带顺序访问指针的B+Tree

			所有叶子节点都是同一层  中间节点不放data，只放key，存储空间也减低了

 


