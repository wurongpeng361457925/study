String是不可变的，有什么好处？
		1.多线程中是安全的，不需要做任何同步操作
		2.可以在java运行时节省堆空间。 不同的字符串变量可以引用池中的相同的字符串。如果字符串是可变的话，任何一个变量的值的改变，
			就会影响到其他变量，那么字符串常量池也就没有任何意义了
		3.值不可变，可用来存储数的安全性有保证
		
如何分割一个String ？
		public String[] split(String regex);
		
		public String[] split(String regex,int limit);
		
什么是字符串常量池？
		是用来存储字符串的，它存在与Java堆内存中
		直接使用“”声明的String对象会直接存储在 常量池中
		若不是使用“”声明的String对象，可以使用String提供的intern()方法。
		intern()方法会从字符串常量池中查询当前字符串是否存在，若不在就将当前字符串放入常量池中
		
String str = new String("cat");  将会创建几个字符串
		1个或者2个。
		若字符串常量池中已经存在字符串"cat"，那就只会创建一个“cat”字符串：                    这种情况创建一个
		若字符串常量池中没有“cat”，首先会在字符串常量池中创建，然后才在堆内存中创建，  这种情况创建两个
		
		
String 的intern()方法  ？？
		当intern()方法被调用，若字符串常量池中含有一个字符串与当前调用方法的字符串equals()相等，那么就会返回字符串常量池中的字符串；
		若字符串常量池中没有当前调用intern()的字符串，则首先将当前调用intern()方法的字符串加入到常量池中，再返回引用。
		
String是线程安全的吗？？？
		是的，String类型被final修饰，是不可变类型
		

为什么在使用HashMap的时候总是用String 做key ？？
		因为字符串是不可变的，当创建字符串时，它的hashCode()被缓存下来，不需要再次计算。
		而HashMap底层实现是通过key的hashCode()来确定value的存储位置，相比其他对象更快！
	
		
String s1 = "abc";
String s2 = new StringBuilder(s1);
System.out.println(s1.equals(s2));  
这段代码输出什么？
		输出false，因为s2不是String 类型，String 的equals()方法进行了类型判断  instanceof
			参考：
				public boolean equals(Object anObject) {
					...
								if (anObject instanceof String) {...}
				}
				
				StringBuilder,StringBuffer并没有继承String类型，所以 anObject instanceof String 为false
				public final class StringBuilder
														extends AbstractStringBuilder
																	implements java.io.Serializable, CharSequence
																	

				